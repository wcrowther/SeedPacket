@page
@model RowsModel

@{
    ViewData["Title"] = "Generate 25k Rows";
}

<div class="row">
    <div class="col-md-12">
        <h2>@ViewData["Title"]</h2>
        <h4 class="byline bottom-margin-big">
			This example generates 1k Accounts with 4k Invoices & 20k InvoiceItems
		</h4>

		<p>
			This example demonstrates generating <b>1000 Account records</b>, each with <b>0-4 Invoices</b>, and each Invoice with
			<b>1-8 InvoiceItems</b>. It highlights the ability to efficiently handle complex nested data with large volumes.
		</p>
		<p>
			The controller pre-generates 20,000 InvoiceItems and 4000 Invoices. These cached lists are accessed via 
			<b>Funcs.GetCacheItemsRandom()</b> and <b>Funcs.GetCacheItemsNext()</b> to retrieve random or sequential items. 
			Random retrieval is slower—about 150% longer—due to shuffling overhead.
		</p>
		<p>Item count is controlled by min/max parameters; setting both equal ensures a fixed number. Items are removed
			from the cache by default unless remove = false. If the cache runs out of items, the method fails silently,
			so estimating row counts beforehand is recommended.
		</p>
		<p>
			<b>Generating 25,000 rows took <i class="emphasis">@Model.ElapsedTime ms.</i></b>
		</p>
		<p>
			The code also includes an example of extracting the <b>GetInvoices()</b> rule into an external function, which applies 
			logic to match <b>Invoice.AccountId</b> with its parent <b>AccountId</b>, aiding both organization and debugging.
		</p>
    </div>
</div>

<div class="row">
    <div class="col-md-12">
        <partial name="_Example_Rows_Code" />
    </div>
</div>

<div class="row">
    <div class="col-md-12">
        <partial name="_25kRows" model="@Model.Accounts" />
    </div>
</div>

<div class="row">
    <div class="col-md-12">
        <a class="nextpage pull-right" href="/Rules">
            Rules<span class="glyphicon glyphicon-triangle-right" aria-hidden="true"></span>
        </a>
    </div>
</div>
